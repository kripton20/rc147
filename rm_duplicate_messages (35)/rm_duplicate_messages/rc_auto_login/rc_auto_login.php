<?php
/**
* Использование очень простое, вам нужен только RoundcubeAutoLogin.php, cookiejar.txt создается и удаляется на лету.
* Использование из php-скрипта: включите класс и следующий код в свой php-скрипт и сделайте вызов функций.
*/
// ВЫзываем функцию "rc_auto_login()" - запус всей процедуры автоматической авторизации.
rc_auto_login();

function rc_auto_login(){
// Переменным присвоим значения логина и пароля.
$email              = $_GET['email'];
$password           = $_GET['password'];
// Текущая папка и подпапка для обработки.
$folder             = $_GET['folder'];
$sub_folder         = $_GET['sub_folder'];
// Получим глобальные переменные:
// Глобальный массив $_SERVER['SCRIPT_NAME'] - содержит путь к текущему исполняемому скрипту.
$server_script_name = $_SERVER['SCRIPT_NAME'];
// Обрезаем строку. Вместо массива - используем список.
list($a, $server_folder) = explode('/', $server_script_name);

// Если авторизации нет - авторизуемся, иеаче просто обновим текущую страницу.
// Работает при корректном завершении сессии.
//$a                 = 1;
//unset($_COOKIE);
//if (!isset($_COOKIE['roundcube_sessid']) && !isset($_COOKIE['roundcube_sessauth'])) {
    //if (!$_COOKIE['roundcube_sessauth']) {
    //if (!isset($cookies)) {
    //if (!$_SERVER['HTTP_COOKIE']) {
    //if (!isset($_SESSION)) {
    // Загружаем файл класса (инициируем конструкторы класса RoundcubeLogin.class):
    // вместо указания абсолютного пути используем предопределенную константу __DIR__,
    // сообщающую текущий каталог скрипта.
    require_once(__DIR__ . '/RoundcubeLogin.class.php');
    // Установим путь к домену Roundcube.
    // Создаём экземпляр класса "RoundcubeLogin" в переменной "$rc".
    // $_SERVER['REQUEST_SCHEME'] - схема запроса: http или https.
    // $_SERVER['SERVER_NAME'] - имя хоста, обычно совпадает с доменом.
    // $_SERVER['SERVER_PORT'] - порт сервера.
    $rc      = new RoundcubeLogin($_SERVER['REQUEST_SCHEME']
        . '://' . $_SERVER['HTTP_HOST']
        . '/' . $server_folder . '/');
    // Получим cookies:
    // Вызываем функцию "login()" из класса "RoundcubeLogin" в переменной "$rc".
    $cookies = $rc->login($email, $password);
    // Теперь вы можете установить файлы cookie с помощью функции setcookie php или с помощью
    // любой другой функции используемого вами фреймворка.
    foreach ($cookies as $cookie_name => $cookie_value) {
        setcookie($cookie_name, $cookie_value, 0, '/', '');
    }

    // И перенаправить на roundcube с установленными куками.
    $rc->redirect($folder, $sub_folder);
    // Проверим ответ от сервера и если нет списка писем - выполним POST-запрос серверу
    // с командой авторизации на сервере.
    // Если переменная "rcLoginStatus" = 1 - значит вход выполнен.
    $ab=0;
    // Завершение программы.
    exit;
    
//}else {
//    /**
//    * Выполняем обновление текущей страницы в приложении Roundcube.
//    */
//    // $_SERVER['REQUEST_SCHEME'] - схема запроса: http или https.
//    // $_SERVER['HTTP_HOST'] - имя сервера, которое, как правило, совпадает с доменным именем сайта,
//    //                         расположенного на сервере.
//    // Формируем строку запроса (URL).
//    $rcPath = $_SERVER['REQUEST_SCHEME']
//    . '://' . $_SERVER['HTTP_HOST']
//    . '/' . $server_folder
//    . '/' . "?_task=mail&_mbox=INBOX%2FArchive%2F"
//    . $folder . "%2F" . $sub_folder;
//    /**
//    * header — Отправка HTTP-заголовка
//    * Описание
//    * header(string $header , bool $replace = true , int $response_code = 0 ):void
//    * Функция header() используется для отправки HTTP-заголовка. В спецификации HTTP/1.1 есть подробное описание HTTP-заголовков.
//    * Помните, что функцию header() можно вызывать только если клиенту ещё не передавались данные.
//    * То есть она должна идти первой в выводе, перед её вызовом не должно быть никаких HTML-тегов, пустых строк и т.п.
//    * Довольно часто возникает ошибка, когда при чтении кода файловыми функциями, вроде include или require,
//    * в этом коде попадаются пробелы или пустые строки, которые выводятся до вызова header().
//    * Те же проблемы могут возникать и при использовании PHP/HTML в одном файле.
//    */
//    header("Location: {$rcPath}");
//    // Выход из программы.
//    exit;
//}
}


// Объявление защищённого метода - "protected function".
// К protected (защищенным) свойствам и методам можно получить доступ либо из содержащего их
// класса, либо из его подкласса. Никакому внешнему коду доступ к ним не предоставляется.
// Запечатаем функцию "file_put_contents" в нами созданную функцию "write_log_file" с параметром "args".
function write_log_file ($args)
{
    // Пишем содержимое (строку) в файл,
    // используя флаг FILE_APPEND flag для дописывания содержимого в конец файла и флаг LOCK_EX
    // для предотвращения записи данного файла кем - нибудь другим в данное время.
    /**
    * Функция записи отладочной информации в log-файл.
    * file_put_contents — Пишет данные в файл
    * file_put_contents(string $filename , mixed $data , int $flags = 0 , resource $context = ?):int
    * Функция идентична последовательным успешным вызовам функций fopen(), fwrite() и fclose().
    * Если filename не существует, файл будет создан. Иначе, существующий файл будет
    * перезаписан, за исключением случая, если указан флаг FILE_APPEND.
    * @param filename   Путь к записываемому файлу.
    * @param data       Записываемые данные. Может быть типа string, array или ресурсом потока.
    *                   Если data является потоковым ресурсом (stream), оставшийся буфер этого потока
    *                   будет скопирован в указанный файл.
    *                   Это похоже на использование функции stream_copy_to_stream().
    *                   Также вы можете передать одномерный массив в качестве параметра data.
    *                   Это будет эквивалентно вызову file_put_contents($filename, implode('', $array)).
    * @param flags      Значением параметра flags может быть любая комбинация следующих флагов,
    *                   соединённых бинарным оператором ИЛИ (|).
    * Доступные флаги:  FILE_USE_INCLUDE_PATH - Ищет filename в подключаемых директориях. Подробнее смотрите
    * директиву include_path; FILE_APPEND - Если файл filename уже существует, данные будут дописаны в конец
    * файла вместо того, чтобы его перезаписать; LOCK_EX - Получить эксклюзивную блокировку на файл на время
    * записи. Другими словами, между вызовами fopen() и fwrite() произойдёт вызов функции flock().
    * Это не одно и то же, что вызов fopen() с флагом "x".
    */
    file_put_contents(
        'D:\WEB\X5\tmp\logs\rm_session_debug.log',
        /**
        * print_r — Выводит удобочитаемую информацию о переменной.
        * Если вы хотите перехватить вывод print_r(), используйте параметр return. Если его значение равно true,
        * то print_r() вернёт информацию вместо вывода в браузер.
        */
        print_r($args, true),
        FILE_APPEND | LOCK_EX
    );
}
?>

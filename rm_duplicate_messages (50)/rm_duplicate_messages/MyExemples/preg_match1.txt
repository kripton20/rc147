/**
* preg_match — выполняет проверку на соответствие регулярному выражению.
*
* Описание:
* preg_match(string $pattern, string $subject, array &$matches=null, int $flags=0, int $offset=0):int|FALSE
*
* Ищет в заданном тексте subject совпадения с шаблоном pattern.
*
* Список параметров:
* @var pattern Искомый шаблон в виде строки.
* @var subject Входная строка.
* @var matches В случае, если указан дополнительный параметр matches, он будет заполнен результатами поиска.
*  Элемент $matches[0] будет содержать часть строки, соответствующую вхождению всего шаблона,
*  $matches[1] - часть строки, соответствующую первой подмаске и так далее.
* @var flags   flags может быть комбинацией следующих флагов:
*  PREG_OFFSET_CAPTURE - В случае, если этот флаг указан, для каждой найденной подстроки
*  будет указана её позиция (в байтах) в исходной строке. Необходимо помнить, что этот флаг меняет
*  формат возвращаемого массива matches в массив, каждый элемент которого содержит массив,
*  содержащий в индексе с номером 0 найденную подстроку, а смещение этой подстроки в параметре
*  subject - в индексе 1.
*  PREG_UNMATCHED_AS_NULL - Если этот флаг передан, несовпадающие подмаски будут представлены значениями null; в противном случае они
*  отображаются в виде пустых строк (string).
* @var offset  Обычно поиск осуществляется слева направо, с начала строки. Можно использовать дополнительный параметр offset для указания
*  альтернативной начальной позиции для поиска (в байтах).
* @return preg_match() возвращает 1, если параметр pattern соответствует переданному параметру subject, 0 если нет, или FALSE в случае ошибки.
*
* Замечание:
* Использование параметра offset не эквивалентно замене сопоставляемой строки выражением substr($subject, $offset) при вызове функции preg_match(),
* поскольку шаблон pattern может содержать такие условия как ^, $ или (?<=x).
* Сравните:
* В качестве альтернативы substr(), используйте утверждение \G вместо якоря ^ или модификатор A. Оба они работают с параметром offset.
*/